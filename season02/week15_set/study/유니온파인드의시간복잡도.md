**결론부터 말하면**, **최신(표준) Union-Find(Disjoint Set) 알고리즘**에서
- `find` / `union` 연산의 **엄밀한 시간 복잡도**는 **\( \alpha(n) \)** (역 아커만 함수)로 알려져 있습니다.
- \(\alpha(n)\)는 **매우 천천히 증가**하기 때문에, **실질적으로 거의 O(1)**로 간주됩니다.

다만, **경로 압축(Path Compression)** 과 **union by rank/size** 최적화를 적용하기 전의 **기본 트리 구조**만 고려하면,
- 최악의 경우 한쪽에만 계속 연결되는 긴 체인 형태가 되어(“degenerate tree”),
    - `find` 연산이 최대 O(n) 시간
- 하지만 **union by rank 또는 union by size** 만 적용하더라도, 트리 높이가 **log n** 정도로 제한되므로
    - `find` 연산이 O(log n)
    - `union` 연산도 `find`를 2번 호출 후 연결하므로 O(log n)이 됩니다.

즉, **“log n”** 은 (1) **union by rank/size** 만 적용된 경우의 **최악 시간 복잡도**를 가리킵니다.  
그 위에 **경로 압축**까지 추가 적용하면, **이론적으로 O(α(n))** (거의 O(1)과 동일) 이 됩니다.

---

## 1. 왜 기본 구조는 O(n)이 나올 수 있는가?
- 아무 최적화 없이, `union` 시 매번 “무조건 첫 번째 트리의 루트를 두 번째 트리의 루트 밑에” 걸어준다고 가정해 봅시다.
- 운이 나쁘면(혹은 데이터 삽입 순서가 특정하게 되면),
    - 원소가 줄줄이 한쪽 루트 밑으로만 연결되어서 **일직선 체인**이 생길 수 있습니다.
    - 이때 `find(x)`를 호출하면, 루트까지 가는 경로가 최대 n 단계일 수 있어 **O(n)** 이 됩니다.

---

## 2. union by rank(또는 size)의 효과 – O(log n)
- **Rank(깊이) 또는 Size(트리 내 원소 수)** 를 기준으로, 항상 “더 작은 트리”가 “더 큰 트리” 밑으로 붙도록 합니다.
- 이렇게 하면, 트리의 높이가 **log n**을 넘어가지 않게 제한됩니다(‘균형 잡힌 트리’ 형태).
- 따라서 `find` 연산 시, 루트까지 올라가는 비용이 최대 log n 정도가 됩니다.
- `union` 연산은 내부적으로 `find` 2번 + 연결 1번이므로, 역시 O(log n)입니다.

---

## 3. 경로 압축(Path Compression)까지 적용하면 – O(α(n))
- **경로 압축** 기법은, `find(x)` 할 때 **재귀**(또는 반복)로 루트에 도달한 뒤,  
  **거쳐간 모든 노드**가 **바로 루트**를 가리키도록(부모를 루트로 갱신) 해줍니다.
- 이 기법은 **트리 구조를 매우 빠르게 납작(flatten)하게** 만들기 때문에,
    - 반복적으로 `find` 연산을 수행하면, 대부분의 노드가 루트에 직접 연결된 형태가 되어버립니다.
- 이때의 시간 복잡도는 수학적으로 \(\alpha(n)\) (Inverse Ackermann Function)으로 증명되는데,
    - 이 값은 **n이 우주적 크기로 커져도 5 이하** 정도에 머무는, 사실상 **상수**에 준하는 아주 느리게 증가하는 함수입니다.

---

## 4. 요약
1. **기본 union-find(최적화 없음)**
    - `find`, `union` → **O(n)** (최악시)
2. **union by rank/size만** 적용
    - `find`, `union` → **O(log n)**
3. **union by rank/size + 경로 압축**(일반적으로 “표준”이라 부름)
    - 이론상 **O(\(\alpha(n)\))** → 실제로는 **거의 O(1)**

> 흔히 교과서 등에서는 “Union-Find의 시간 복잡도는 거의 상수 시간”이라고 요약하는데,  
> 이는 가장 강력한 최적화(경로 압축 + union by rank/size)가 적용된 상태를 전제하기 때문입니다.

