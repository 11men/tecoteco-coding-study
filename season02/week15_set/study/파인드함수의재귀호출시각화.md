

## 전제: 연쇄 구조 상태

- 배열 `parent` 의 상태:

  | 인덱스 | 0 | 1 | 2 | 3 | 4 |
    |--------|---|---|---|---|---|
  | 값     | 0 | 0 | 1 | 2 | 3 |

- 즉,
    - `parent[0] = 0` (자기 자신이 루트)
    - `parent[1] = 0`
    - `parent[2] = 1`
    - `parent[3] = 2`
    - `parent[4] = 3`

이를 그림으로 나타내면:

```
4  -> 3  -> 2  -> 1  -> 0
                ↑
                루트(자기 자신)
```

여기서 `find(4)`를 호출하여 최종 루트를 찾는 과정을 **재귀 호출** 관점에서 상세하게 살펴봅시다.

---

## 1. 코드(Find 함수) 확인

```java
public int find(int x) {
    // (A) 루트 확인
    if (parent[x] == x) {
        return x;
    }
    // (B) 재귀 + 경로 압축
    parent[x] = find(parent[x]);
    return parent[x];
}
```

---

## 2. `find(4)` 호출 시 스택 변화

### 2.1 첫 번째 호출: `find(4)`

1) **스택에 `find(4)`** 진입
    - **함수 파라미터** `x = 4`
2) 코드 (A) `if (parent[4] == 4) { ... }` 검사
    - 현재 `parent[4] = 3`, 즉 `3 == 4` 는 거짓 → **재귀로 넘어감**
3) 코드 (B) `parent[4] = find(3);` 호출

**스택 스냅샷 (호출 직후)**

```
(Top)
┌─────────────────────┐
│ find(4)  [x=4]       │
│  - (A) if(...) -> no │
│  - (B) parent[4] = find(3); <--- 여기서 대기중
└─────────────────────┘
```

---

### 2.2 두 번째 호출: `find(3)`

1) **스택에 `find(3)`** 추가
    - 함수 파라미터 `x = 3`
2) (A) `if (parent[3] == 3)` 검사
    - `parent[3] = 2`, 즉 `2 == 3` ? 거짓
    - 재귀로 넘어감
3) (B) `parent[3] = find(parent[3]) = find(2)`

**스택 스냅샷**

```
(Top)
┌─────────────────────┐
│ find(3)  [x=3]       │
│  - (A) if(...) -> no │
│  - (B) parent[3] = find(2); <--- 대기
└─────────────────────┘
┌─────────────────────┐
│ find(4)  [x=4]       │  // 아래에서 기다리는 중
│  - (B) parent[4] = find(3);
└─────────────────────┘
```

---

### 2.3 세 번째 호출: `find(2)`

1) **스택에 `find(2)`** 추가
    - 함수 파라미터 `x = 2`
2) (A) `if (parent[2] == 2)` 검사
    - `parent[2] = 1`, 즉 `1 == 2` ? 거짓
    - 재귀로 넘어감
3) (B) `parent[2] = find(parent[2]) = find(1)`

**스택 스냅샷**

```
(Top)
┌─────────────────────┐
│ find(2)  [x=2]       │
│  - (A) if(...) -> no │
│  - (B) parent[2] = find(1); <--- 대기
└─────────────────────┘
┌─────────────────────┐
│ find(3)  [x=3]       │
│  - (B) parent[3] = find(2);
└─────────────────────┘
┌─────────────────────┐
│ find(4)  [x=4]       │
│  - (B) parent[4] = find(3);
└─────────────────────┘
```

---

### 2.4 네 번째 호출: `find(1)`

1) **스택에 `find(1)`** 추가
    - 함수 파라미터 `x = 1`
2) (A) `if (parent[1] == 1)` 검사
    - `parent[1] = 0`, 즉 `0 == 1` ? 거짓
    - 재귀로 넘어감
3) (B) `parent[1] = find(parent[1]) = find(0)`

**스택 스냅샷**

```
(Top)
┌─────────────────────┐
│ find(1)  [x=1]       │
│  - (A) if(...) -> no │
│  - (B) parent[1] = find(0); <--- 대기
└─────────────────────┘
┌─────────────────────┐
│ find(2)  [x=2]       │
│  - (B) parent[2] = find(1);
└─────────────────────┘
┌─────────────────────┐
│ find(3)  [x=3]       │
│  - (B) parent[3] = find(2);
└─────────────────────┘
┌─────────────────────┐
│ find(4)  [x=4]       │
│  - (B) parent[4] = find(3);
└─────────────────────┘
```

---

### 2.5 다섯 번째 호출: `find(0)`

1) **스택에 `find(0)`** 추가
    - 함수 파라미터 `x = 0`
2) (A) `if (parent[0] == 0)` 검사
    - 현재 `parent[0] = 0`, 즉 `0 == 0` ? **참**
    - **루트 노드를 찾았으므로** 바로 `return 0`

이때, `find(0)` 는 더 이상 재귀 호출 없이 **0** 을 반환하며 스택에서 빠져나옵니다.

**스택 스냅샷 (최종 호출점)**

```
(Top)
┌─────────────────────┐
│ find(0)  [x=0]       │
│  - (A) if (0 == 0) -> true -> return 0
└─────────────────────┘
┌─────────────────────┐
│ find(1)  [x=1]       │
│  - (B) parent[1] = find(0);
└─────────────────────┘
┌─────────────────────┐
│ find(2)  [x=2]       │
│  - (B) parent[2] = find(1);
└─────────────────────┘
┌─────────────────────┐
│ find(3)  [x=3]       │
│  - (B) parent[3] = find(2);
└─────────────────────┘
┌─────────────────────┐
│ find(4)  [x=4]       │
│  - (B) parent[4] = find(3);
└─────────────────────┘
```

---

## 3. 반환 과정 (스택 언와인딩)

이제 **스택**이 “맨 위”부터 차례로 내려오면서, 각 호출에서 **리턴값**을 전달하고,  
그 값을 이용해 `parent[...]` 를 갱신(경로 압축)하는 과정을 순서대로 봅시다.

### 3.1 `find(0)` 의 리턴

- `find(0)` **리턴값 = 0**
- 스택에서 `find(0)` 프레임이 사라지고, 그 결과가 **하위(이전) 호출**인 `find(1)`에 전달됩니다.

### 3.2 `find(1)` 로 복귀

- **리턴값**(0)을 받아, `find(1)` 의 (B) 구문을 마저 실행
  ```java
  // parent[1] = find(0); 
  // find(0)은 0을 반환
  parent[1] = 0; 
  return parent[1]; // 즉 0 반환
  ```
- 따라서 `parent[1] = 0` (이미 0이었지만, 혹시 1이었다면 여기서 갱신됨)
- `find(1)` 또한 **리턴값 = 0** 으로 끝남 → 스택에서 `find(1)` 빠져나옴

### 3.3 `find(2)` 로 복귀

- **리턴값**(0)을 받아, `find(2)` 의 (B) 구문을 마저 실행
  ```java
  // parent[2] = find(1); 
  // find(1)은 0을 반환
  parent[2] = 0; 
  return parent[2]; // 즉 0 반환
  ```
- 따라서 `parent[2] = 0`  
  (원래 2 → 1 이었던 것이, 이번에 **바로 0**을 가리키도록 갱신)
- `find(2)` 또한 **리턴값 = 0** 으로 끝남 → 스택에서 `find(2)` 빠져나옴

### 3.4 `find(3)` 로 복귀

- **리턴값**(0)을 받아, `find(3)` 의 (B) 구문을 마저 실행
  ```java
  // parent[3] = find(2);
  // find(2)는 0을 반환
  parent[3] = 0;
  return parent[3]; // 0
  ```
- 따라서 `parent[3] = 0`
- `find(3)` 또한 **리턴값 = 0** 으로 끝남 → 스택에서 `find(3)` 빠져나옴

### 3.5 `find(4)` 로 복귀

- **리턴값**(0)을 받아, `find(4)` 의 (B) 구문을 마저 실행
  ```java
  // parent[4] = find(3);
  // find(3)는 0을 반환
  parent[4] = 0;
  return parent[4]; // 0
  ```
- 따라서 `parent[4] = 0`
- `find(4)` 마지막으로 **리턴값 = 0** 으로 끝남 → 스택에서 `find(4)` 빠져나옴

### 3.6 최종 parent 배열

최종적으로, **모든 노드**가 **루트 0**을 직접 가리키도록 경로 압축이 이루어집니다.

\[
parent = [0, 0, 0, 0, 0]
\]

---

## 4. 최종 요약 (스택 그림)

아래는 전체 과정을 **한눈에** 요약한 그림 형태(텍스트 기반)입니다.  
맨 왼쪽이 **호출 스택**이 쌓이는 과정, 맨 오른쪽이 **스택이 해제**되면서 경로 압축되는 과정이라 볼 수 있습니다.

```
┌───────────────────────────────────────────────────────┐
│                    호출 (Call)                      │
└───────────────────────────────────────────────────────┘

(1) call find(4)  
   parent[4] != 4 → find(3)

(2) call find(3)
   parent[3] != 3 → find(2)

(3) call find(2)
   parent[2] != 2 → find(1)

(4) call find(1)
   parent[1] != 1 → find(0)

(5) call find(0)
   parent[0] == 0 → return 0 (루트 발견)


       [ Stack 상태: Top ~ Bottom ]
       ┌─────────────────────┐   <-- find(0)
       │ find(0)             │
       └─────────────────────┘
       ┌─────────────────────┐   <-- find(1)
       │ find(1)             │
       └─────────────────────┘
       ┌─────────────────────┐   <-- find(2)
       │ find(2)             │
       └─────────────────────┘
       ┌─────────────────────┐   <-- find(3)
       │ find(3)             │
       └─────────────────────┘
       ┌─────────────────────┐   <-- find(4)
       │ find(4)             │
       └─────────────────────┘


┌───────────────────────────────────────────────────────┐
│                   반환 (Return)                      │
└───────────────────────────────────────────────────────┘

(5) find(0) → returns 0

(4) find(1) : parent[1] = 0; return 0

(3) find(2) : parent[2] = 0; return 0

(2) find(3) : parent[3] = 0; return 0

(1) find(4) : parent[4] = 0; return 0

결국 parent 배열: [0, 0, 0, 0, 0]
```

---

### 핵심 포인트

1. **재귀 호출**로 인해 스택 프레임이 **깊이** 쌓여 들어간다.
2. 가장 깊은 곳(= 루트 노드)에서 조건을 만족하여 **리턴**될 때, **하위 스택**부터 차례대로 해제(pop)된다.
3. 리턴값(루트 인덱스)을 받아, 각 단계에서 `parent[x]`를 바로 루트로 갱신하는 **경로 압축(Path Compression)** 이 이루어진다.
4. 결과적으로 한 번의 `find(4)` 호출로, 4 → 3 → 2 → 1 까지 이어진 체인이 **모두** 0을 직접 바라보게 된다.
