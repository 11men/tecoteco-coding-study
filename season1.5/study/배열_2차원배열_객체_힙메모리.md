
# 0. 이 문서에 대해서

이 문서는 **Java에서의 배열, 2차원 배열, 객체, 그리고 힙 메모리** 개념을 다루며, 각각의 특징과 관계를 이해하기 위해 작성되었습니다.   
배열에서부터 객체로 개념이 확장되는 과정을 **시각 자료**와 함께 살펴보고, 코딩 테스트나 실제 개발 상황에서도 활용할 수 있도록 정리했습니다. 😎   


# 1. 배열(Array)

## 1.1 배열의 개념

- **정의**: 같은 타입의 데이터를 연속된 메모리 공간(자바에서는 연속적이라고 보기보다는 “배열 객체 안의 요소가 인덱스로 이어져 있다”고 이해)에 저장하기 위한 자료 구조입니다.
- **특징**:
    1. **고정 크기**: 배열을 생성할 때 크기(길이)가 확정되고, 이후 변경 불가
    2. **인덱스를 이용한 접근**: 인덱스를 통한 임의 접근(랜덤 액세스)이 가능
    3. **배열도 객체**: 자바에서 배열은 `Object`를 상속받는 하나의 객체입니다.

## 1.2 배열의 메모리 구조

1. **힙 메모리에 생성**
    - 자바에서 `new`를 통해 생성된 모든 인스턴스(객체 및 배열)는 **힙 메모리(Heap Memory)**에 저장됩니다.
2. **참조 변수는 스택에 존재**
    - 메서드 내부에서 선언한 변수(예: `int[] arr`)는 스택 메모리에 위치하며, 배열 객체의 **주소(참조값)**를 저장합니다.
    - 실제 배열의 데이터가 저장된 공간은 힙에 존재합니다.

> 예시
> ```java
> int[] arr = new int[5]; 
> arr[0] = 10;
> ```
>
> - `arr` 변수(스택): 배열 객체의 참조(주소) 보관
> - `new int[5]`로 할당된 배열(힙): 요소 5개를 저장할 공간

### 1.2.1 시각적 예시(1차원 배열)

```
┌─────────┐
│  Stack  │
├─────────┤
│ arr ────────────────┐   (arr 변수는 스택에 있음)
└─────────┘           │
                      ↓ (힙 영역에 있는 배열 객체의 주소)
                ┌──────────────────┐
                │  arr 객체(힙)    │
                ├──────────────────┤
                │  [0]: 10         │
                │  [1]: 0          │
                │  [2]: 0          │
                │  [3]: 0          │
                │  [4]: 0          │
                └──────────────────┘
```

---

# 2. 2차원 배열(2D Array)

## 2.1 2차원 배열의 개념

- **정의**: “배열의 배열” 형태로, 자바에서는 `타입[][]`로 선언합니다.
- **특징**:
    1. **가변 길이 가능**: 각 **행**이 별도의 배열 객체로 할당되므로, `matrix[0].length`, `matrix[1].length` 등 행마다 길이가 달라질 수 있음
    2. **실제로는 1차원 배열들의 배열**: 예를 들어 `new int[3][4]` 선언 시,
        - 길이 3의 1차원 배열(행 배열)이 먼저 만들어지고
        - 이 1차원 배열의 각 요소는 길이 4의 별도 1차원 배열 객체(열 배열)를 가리킴

## 2.2 2차원 배열의 메모리 구조

> 예시
> ```java
> int[][] matrix = new int[3][4];
> matrix[0][0] = 1;
> matrix[1][2] = 2;
> ```
>
> - `matrix`(스택): “행 배열” 객체의 주소를 갖고 있음
> - “행 배열” 객체(힙): 길이 3의 `int[]`를 요소로 가지는 **배열의 배열**
> - 각 행(`matrix[0]`, `matrix[1]`, `matrix[2]`)도 힙에 별도로 할당된 `int[4]` 배열 객체

### 2.2.1 시각적 예시(2차원 배열)

```
┌─────────┐
│  Stack  │
├─────────┤
│ matrix ────────────┐      (matrix 변수는 스택에 존재)
└─────────┘          │
                     ↓ (행 배열의 주소)
                ┌──────────────────┐
                │  matrix(힙)      │  <-- 행 배열 객체
                ├──────────────────┤
                │  [0] ────────────┐-->  ┌───────────────────┐
                │  [1] ────────────┼--->  │   matrix[1](힙)   │
                │  [2] ────────────┘-->  └───────────────────┘
                └──────────────────┘

(위 그림의 [0], [1], [2] each:
  --> 'int[4]' 형태의 배열 객체로, 각각 힙에 따로 존재)

     ┌───────────────────┐
     │   matrix[0](힙)   │
     ├───────────────────┤
     │ [0] : 1           │
     │ [1] : 0           │
     │ [2] : 0           │
     │ [3] : 0           │
     └───────────────────┘
     ┌───────────────────┐
     │   matrix[1](힙)   │
     ├───────────────────┤
     │ [0] : 0           │
     │ [1] : 0           │
     │ [2] : 2           │
     │ [3] : 0           │
     └───────────────────┘
     ┌───────────────────┐
     │   matrix[2](힙)   │
     ├───────────────────┤
     │ [0] : 0           │
     │ [1] : 0           │
     │ [2] : 0           │
     │ [3] : 0           │
     └───────────────────┘
```

---

# 3. 객체(Object)

## 3.1 자바 객체의 개념

- **정의**: 클래스(또는 인터페이스, 추상 클래스 등)를 통해 생성된 **인스턴스**입니다.
- **배열 또한 객체**: 자바에서 모든 배열(`int[]`, `String[]` 등)은 `Object` 클래스를 상속받는 객체입니다.
    - `instanceof` 연산자로 확인 시, `int[]`도 `Object`의 인스턴스로 간주됩니다.

## 3.2 객체의 메모리 구조

1. **힙 메모리 할당**
    - `new` 키워드를 통해 생성된 모든 객체는 힙 메모리에 위치합니다.
2. **참조(주소)로 접근**
    - 스택 혹은 다른 객체의 필드(참조 타입)에 객체의 주소를 보관하고, 그 주소를 통해 힙의 실제 데이터를 접근합니다.

> 예시
> ```java
> class MyClass {
>     int value;
> }
>
> MyClass obj = new MyClass();
> obj.value = 100;
> ```
>
> - `obj`(스택): `MyClass` 인스턴스의 **주소**를 저장
> - `new MyClass()`(힙): `value` 필드(= 100) 저장

---

# 4. 힙 메모리(Heap Memory)와 자동 메모리 관리

## 4.1 힙 메모리

- **정의**: 자바에서 `new`로 생성된 모든 인스턴스(배열, 객체)가 **동적으로 할당**되는 영역
- **가비지 컬렉션(GC)**: 더 이상 참조되지 않는 객체(도달 불가능한 객체)를 자동으로 수거하여 메모리를 회수

## 4.2 주의사항

1. **메모리 누수(Memory Leak) 방지**
    - 참조가 끊기지 않도록 객체를 계속 참조하는 구조라면, 가비지 컬렉터가 회수하지 못해 점점 힙이 부족해질 수 있음
2. **OutOfMemoryError**
    - 힙 공간이 부족해 새 객체를 더 이상 할당할 수 없을 때 발생
3. **객체 생성 비용**
    - 과도한 객체(또는 배열) 생성 & 파괴는 빈번한 GC를 유발할 수 있어 성능 저하로 이어짐

---

# 5. 배열 → 2차원 배열 → 객체, 개념 확장의 흐름

1. **배열의 기초: 동일 타입의 연속된 데이터**
    - 가장 단순한 형태의 자료 구조로, 정해진 크기만큼 요소들을 담는 목적
2. **2차원 배열: 배열을 확장하여 행과 열 구조 표현**
    - 실제로는 1차원 배열들의 배열이며, “배열 객체”를 원소로 가지는 또 다른 배열
    - 복잡한 데이터를 ‘행-열’ 형태로 관리 가능
3. **객체: 데이터와 메서드를 포함하는 고차원 추상화**
    - 배열과 달리, 원하는 만큼 다양한 속성과 동작을 묶어 정의 가능
    - 배열도 결국 객체로 취급 → 동적 할당, 가비지 컬렉션 적용

---

# 6. 전체 요약 및 주목할 점

1. **데이터 저장 관점**
    - 배열(1D): 동일 타입 값들을 인덱스로 빠르게 접근하고 싶을 때 활용
    - 2차원 배열(2D): 행과 열 형태로 접근·관리 필요할 때 사용
    - 객체: 구조화된 데이터 + 동작(메서드)까지 포함해 추상화를 높이고 싶을 때 사용
2. **메모리 관점**
    - 모든 배열과 객체는 힙 메모리에 생성되며, 스택에서는 이들의 주소(참조)만 관리
    - 2차원 배열은 “배열 + 배열” 구조여서 행마다 힙에 별개 객체로 존재할 수 있음
3. **참조(주소)의 개념**
    - `참조 타입 변수`가 여러 개라도, 같은 힙 객체(배열, 객체)를 가리킬 수 있음
    - 참조가 없어지면(= 도달할 방법이 없어지면) GC에 의해 회수될 수 있음
4. **성능 및 최적화**
    - 메모리 연속성(Locality)을 중요하게 생각한다면, 2차원 배열 접근 시 특정 행이나 열을 집중적으로 다룰 때 캐시 미스가 발생할 수 있음을 주의(자바 특유의 “배열의 배열” 구조)
    - 큰 배열을 자주 생성/삭제하기보다는 재사용 등을 고려해 불필요한 GC 유발을 방지

---

## 결론

- **배열**은 동일 타입 데이터를 효율적으로 접근하는 기본 구조
- **2차원 배열**로 확장하면, ‘행-열’ 등 더 복잡한 구조를 구현할 수 있으나, 자바에서 이는 실제 “배열의 배열”이므로 행마다 별도 객체임을 유의
- **객체**는 데이터(필드)와 동작(메서드)를 함께 추상화하여, 더 높은 수준의 모델을 표현
- 모두 힙 메모리에 생성되며, 스택에선 참조만 보관
- “주소값”, “참조”라는 개념이 자바에서 매우 중요하며, 사용이 끝난 객체는 가비지 컬렉션으로 자동 회수
