# 우선순위 큐(Priority Queue)에 대해 알아 보자.

> **이 문서는**
> 1) 우선순위 큐(Priority Queue)와 힙(Heap)이 왜 헷갈리는지,
> 2) 둘의 차이와 공통점은 무엇인지,
> 3) 실제 동작 원리를 간단한 예시와 시각화를 통해 이해하는 것을 목표로 합니다.
---

## 1. 우선순위 큐와 힙은 무엇이길래 항상 같이 언급될까?

**Q1.** _"우선순위 큐랑 힙이라는 말을 자주 같이 듣는데, 이 둘은 같은 건가요?"_

**A1.**
- **우선순위 큐(Priority Queue)**는 '가장 높은(또는 가장 낮은) 우선순위를 가진 요소'를 **빠르게 꺼낼 수 있는 자료구조**를 의미해요.
- **힙(Heap)**은 이 우선순위 큐를 **구현**하기 위한 대표적인 방법 중 하나예요.
- 따라서, '우선순위 큐 = 힙'은 아니지만, **힙은 우선순위 큐를 구현하기 좋은 자료구조**라서 이 둘이 자주 같이 언급되는 거랍니다.

---

## 2. 그렇다면 둘 사이에 어떤 차이가 있나요?

**Q2.** _"힙이 곧 우선순위 큐가 아니라면, 어떤 차이가 있는 거죠?"_

**A2.**
- **우선순위 큐**는 '인터페이스(추상적인 기능)'에 가까운 개념입니다. 즉, `"가장 우선순위가 높은 원소를 빠르게 추출해야 한다"`라는 기능적 요구사항이에요.
- 반면에 **힙**은 그 요구사항을 만족하기 위한 **구현(실체)** 방식 중 하나입니다.
- 실제로 우선순위 큐는 **힙**뿐만 아니라, **정렬된 배열**이나 **트리** 등 다른 방법으로도 구현할 수 있어요.
    - 다만, 시간 복잡도나 구현 편의성 측면에서 힙이 많이 쓰이기 때문에 우선순위 큐 하면 힙부터 떠오르는 것이죠.

---

## 3. 우선순위 큐가 구체적으로 어떻게 동작하나요?

**Q3.** _"정말 우선순위가 높은 값이 항상 맨 앞에서 나오게 하려면 어떻게 해야 하죠?"_

**A3.**
- 일반적인 **우선순위 큐 연산**은 크게 다음과 같이 볼 수 있어요.

1. **삽입(Insert)**: 새로운 원소를 큐에 넣는다.
2. **최고 우선순위 원소 확인(Peek)**: 현재 큐에서 가장 우선순위가 높은 원소가 무엇인지 확인한다. (예: `top()`)
3. **최고 우선순위 원소 꺼내기(Pop)**: 현재 큐에서 가장 우선순위가 높은 원소를 제거하고 반환한다. (예: `pop()`)

- 이를 **힙**으로 구현하면, 최대 힙(max heap) 또는 최소 힙(min heap)을 통해 이런 연산들을 **로그 시간(log n)** 내에 처리하게 돼요.

---

## 4. 힙(Heap)의 개념과 특징은?

**Q4.** _"그럼 힙은 어떤 특징을 가지고 있길래 우선순위 큐 구현에 적합한가요?"_

**A4.**
- 힙(여기서는 **이진 힙(binary heap)**을 가정)은 **완전 이진 트리**(Complete Binary Tree) 형태를 띠고 있어요.
- **부모 노드와 자식 노드 간의 관계**(힙 불변식, heap property)가 특징입니다.
    1. **최대 힙(max heap)**: 부모 노드가 자식 노드보다 항상 크거나 같다. → 루트 노드에는 가장 큰 값
    2. **최소 힙(min heap)**: 부모 노드가 자식 노드보다 항상 작거나 같다. → 루트 노드에는 가장 작은 값
- 이 구조 덕분에, 힙의 루트(root) 노드만 확인하면 가장 우선순위가 높은 원소(최대 혹은 최소)를 **빠르게** 알 수 있어요.
- 삽입과 삭제(최고 우선순위 원소 꺼내기) 시에도 트리 높이(깊이)에 비례하여 **O(log n)** 시간 복잡도를 가집니다.

---

## 5. 힙은 어떻게 삽입하고 삭제하나요?

**Q5.** _"힙에 원소를 삽입하거나 우선순위가 제일 높은 원소를 삭제할 때, 내부에서 무슨 일이 일어나나요?"_

**A5.**
- **삽입(Insert)**
    1. **트리의 가장 마지막 자리에 새 원소를 임시로 넣는다.** (완전 이진 트리 형태 유지)
    2. 힙 속성이 깨졌다면(예: max heap에서 자식 노드가 부모보다 큰 경우), **부모 노드와 자리를 바꿔 올라간다**(heapify up, 혹은 bubble up).
    3. 더 이상 부모보다 크지 않거나 루트에 도달할 때까지 반복한다.

- **최우선순위(루트) 원소 삭제(Delete: pop)**
    1. 루트 노드(최우선순위 원소)를 **반환**한 뒤, 트리의 **마지막 노드**를 루트 자리에 가져온다.
    2. 힙 속성이 깨졌다면(예: max heap에서 루트가 자식보다 작은 경우), 더 큰 자식과 **자리를 바꿔 내려간다**(heapify down, 혹은 bubble down).
    3. 더 이상 자식보다 크거나 같아질 때까지(혹은 리프 노드에 도달할 때까지) 반복한다.

---

## 6. 삽입과 삭제를 예시로 시각화해보자

**Q6.** _"글로만 보면 어렵네요. 예시를 직접 들어서 힙이 어떻게 변하는지 보여주실 수 있나요?"_

**A6.**  
다음은 **최대 힙(max heap)** 예시입니다.

### 6-1. 삽입 예시

초기에 힙이 `3, 2, 1, 7, 8, 4` 를 가진 상태라고 가정해 봅시다. (여기서는 배열 인덱스를 1부터 표기)

```
힙(배열): [ ?, 8, 7, 4, 2, 3, 1 ] 
            ↑     ↑  ↑  ↑  ↑  ↑
         (루트)              (마지막)
```

##### 1. 초기 상태 점검


- 인덱스는 1부터 사용 (인덱스 0은 편의상 비워둠 `?`).
- 실제 데이터는 8, 7, 4, 2, 3, 1 (총 6개).

**각 인덱스별 값**은 다음과 같습니다.

| 인덱스 | 값 | 부모(인덱스/값) | 자식(인덱스/값)   |
|:---:|:---:|:---:|:---------------------:|
| 1   | 8   | - (루트)         | left=2(7), right=3(4) |
| 2   | 7   | 1(8)            | left=4(2), right=5(3) |
| 3   | 4   | 1(8)            | left=6(1), right=7(없음, 배열 범위 초과) |
| 4   | 2   | 2(7)            | -                   |
| 5   | 3   | 2(7)            | -                   |
| 6   | 1   | 3(4)            | -                   |

이를 **완전 이진 트리**로 시각화하면 다음과 같습니다.

```
            (8)         <- 인덱스 1
           /   \
        (7)     (4)     <- 인덱스 2, 3
       /   \    /
     (2)   (3)(1)       <- 인덱스 4,5,6
```

- **최대 힙 성질**: 부모 ≥ 자식
    - 8 ≥ (7, 4), 7 ≥ (2, 3), 4 ≥ (1)
    - 모두 만족하므로 올바른 최대 힙입니다.


##### 2. 삽입할 원소: `9`

새로운 원소 `9`를 삽입(insert)하면, 먼저 **마지막 자리에 임시로** 들어갑니다.  
즉, 배열로 보면 (사이즈가 7이 되어) 아래와 같습니다.

| 인덱스 | 값  | 부모 | 자식                 |
|:---:|:---:|:---:|:---------------------:|
| 1   | 8   | -   | left=2(7), right=3(4) |
| 2   | 7   | 1   | left=4(2), right=5(3) |
| 3   | 4   | 1   | left=6(1), right=7(9) ← 새로 들어온 노드 |
| 4   | 2   | 2   | -                     |
| 5   | 3   | 2   | -                     |
| 6   | 1   | 3   | -                     |
| 7   | 9   | 3(4)| -                     |

트리로 표현하면:

```
            (8)
           /   \
        (7)     (4)
       /   \    / \
     (2)   (3)(1) (9)
```

---

##### 3. 삽입 후 힙 성질을 복구(Heapify Up)

1) 막 삽입된 `9`의 부모는 `4`(인덱스 3)입니다.
    - 최대 힙에서 자식(9)이 부모(4)보다 크면, 둘을 교환해야 합니다.

```
swap(9, 4) 결과:

            (8)
           /   \
        (7)     (9)
       /   \    / \
     (2)   (3)(1) (4)
```
- 이제 인덱스 3에는 9, 인덱스 7에는 4가 갑니다.

2) 바뀐 자리(인덱스 3)에 있는 `9`가 다시 한 번 부모(인덱스 1, 값=8)와 비교됩니다.
    - 9 > 8 이므로 다시 교환!

```
swap(9, 8) 결과:

            (9)
           /   \
        (7)     (8)
       /   \    / \
     (2)   (3)(1) (4)
```

3) 이제 `9`가 루트에 도달했고, 더 이상 부모 노드가 없으므로 상승(Heapify Up) 종료!

---

##### 4. 최종 트리가 완전 이진 트리인지 확인

최종적으로 루트가 `9`가 되었고, 자식 노드들은 (7)과 (8)이며,  
그 하위로 (2), (3), (1), (4)가 채워져 있습니다.

- **마지막 레벨**에 있는 노드가 왼쪽부터 `2, 3, 1, 4` 순서로 차곡차곡 채워져 있으므로, **완전 이진 트리의 형태 유지**가 맞습니다.
- 동시에 최댓값(9)이 루트에 위치했고, 부모 ≥ 자식 관계가 모두 성립하므로 **최대 힙 성질**도 만족합니다.

따라서,

> 1. **완전 이진 트리 성질** (마지막 레벨까지 왼쪽부터 차례대로 채움)
> 2. **부모 ≥ 자식** (최대 힙 불변식)

두 조건 모두 **정상적으로** 만족합니다.




### 6-2. 삭제 예시

**삭제할 원소**: **루트(최대값) `9`**
1) 루트 `9`를 반환(혹은 출력)하고, **마지막 노드**였던 `(4)`를 루트로 올립니다.

```
초기:
           (9)
          /   \
        (7)   (8)
       /  \   /
     (2) (3) (1)
          ^
          (4) ← 마지막 노드

삭제 후:
           (4) ← 루트에 가져옴
          /   \
        (7)   (8)
       /  \   /
     (2) (3) (1)
```

2) **힙 속성 체크(4 vs 자식들)**: 자식 노드(7,8 중) 최대값은 `8`. 4 < 8 이므로, 4와 8을 교환!

```
           (8)
          /   \
        (7)   (4)
       /  \   /
     (2) (3) (1)
```

3) **(4)의 자식들 비교**: 왼쪽 자식은 `1`, 오른쪽 자식은 없음. 4는 1보다 크므로 더 이상 교환할 필요 X.
    - **최종 구조** 완성.

이렇게 최대 힙이 `pop` 연산으로 최댓값을 빼내고, 내부를 재정비하는 과정을 간단히 시각화해 보았습니다.


아래 예시는 **`60, 20, 70, 10, 80, 30, 50, 40`**라는 8개의 원소로 **최대 힙(Max Heap)을 한 번에 구축(Build Heap)** 하는 과정을 단계별로 보여줍니다.

> **Note**
> - “힙을 만드는 방법”은 크게 두 가지가 있습니다.
    >   1) **하나씩 삽입**(insert)하면서 `heapify up` 하는 방식.
>   2) **주어진 배열** 전체를 한 번에 “Bottom-Up”으로 `heapify down` 하여 힙을 만드는 **`build heap`** 방식.
> - 여기서는 일반적으로 많이 사용하는 **`build heap`** (Bottom-Up) 방식을 예시로 듭니다.
    >   - 시간 복잡도가 O(N)이라 크기가 큰 배열을 힙으로 만들 때 유리합니다.

---

### 6-3. 초기 힙을 구축(Build Max Heap) 예시

초기에 주어진 **배열(1-based 인덱스)**:

```
인덱스:    1   2   3   4   5   6   7   8
값:      [60, 20, 70, 10, 80, 30, 50, 40]
```

우리는 이것을 **최대 힙**으로 만들고자 합니다. (부모 노드 ≥ 자식 노드)

##### 1) 배열을 완전 이진 트리 형태로 놓기

우선, 단순히 주어진 순서대로 **완전 이진 트리**에 배치(마지막 레벨까지 왼쪽부터 채움)하면:

```
                 (60)  <- 인덱스 1
                /    \
            (20)      (70)  <- 인덱스 2,3
            /   \     /  \
         (10)  (80) (30) (50) <- 인덱스 4,5,6,7
         /
       (40)  <- 인덱스 8
```

> 이 시점에는 아직 최대 힙 속성이 보장되지 않습니다.  
> **이제** 아래에서부터 `heapify down`을 적용하여, 부모 노드가 자식 노드보다 항상 크도록 재정렬합니다.

---

#### 2) Bottom-Up 방식으로 `heapify` 진행

- **인덱스 `⌊N/2⌋`부터 1까지** 역순으로 내려오면서,  
  각 노드가 **자식들보다 작다면** 교환을 통해 **힙 성질**을 만족시키는 과정을 거칩니다.

> **N = 8**일 때, `⌊N/2⌋ = 4`  
> 즉, **i = 4 → 3 → 2 → 1 순서**로 `heapify`를 호출합니다.

#### (1) i = 4 에서 `heapify down`

- 현재 **노드(인덱스 4)**의 값 = `10`
- 왼쪽 자식(인덱스 8) = `40`, 오른쪽 자식(인덱스 9)은 없음.
- 비교 결과: `10 < 40` → **교환** 필요

```
교환 후:
인덱스:    1   2   3   4   5   6   7   8
값:      [60, 20, 70, 40, 80, 30, 50, 10]
                   ↑         ↑
                (4)번   (8)번 교환
```

트리 형태로 보자면,

```
                (60)
               /    \
            (20)     (70)
            /   \    /  \
         (40)  (80)(30) (50)
         /
       (10)
```

- 이제 인덱스 4에 `40`, 인덱스 8에 `10`이 들어갔습니다.
- 바뀐 자리(인덱스 8)는 자식이 없으니 더 이상 내려갈 필요가 없습니다.

##### (2) i = 3 에서 `heapify down`

- **노드(인덱스 3)**의 값 = `70`
- 왼쪽 자식(인덱스 6) = `30`, 오른쪽 자식(인덱스 7) = `50`
- **두 자식 중 더 큰 값** = `50`
- 부모 `70` vs 자식 `50` → `70 >= 50`이므로 **이미 힙 성질 만족** → 교환 없음

> 변화 없이 그대로 유지됩니다.

#### (3) i = 2 에서 `heapify down`

- **노드(인덱스 2)**의 값 = `20`
- 왼쪽 자식(인덱스 4) = `40`, 오른쪽 자식(인덱스 5) = `80`
- 더 큰 자식 = `80` (인덱스 5)
- `20 < 80` 이므로 교환!

```
교환 후:
인덱스:    1   2   3   4   5   6   7   8
값:      [60, 80, 70, 40, 20, 30, 50, 10]
                  ↑       ↑
              (2)번  (5)번 교환
```

트리로 표현하면,

```
                (60)
               /    \
            (80)     (70)
            /   \    /  \
         (40)  (20)(30) (50)
         /
       (10)
```

- **새로운 노드 위치**는 인덱스 5, 값 = `20`
- 왼쪽 자식(인덱스 10)이나 오른쪽 자식(인덱스 11)은 범위를 벗어나므로, 더 이상 진행할 교환 없음.

#### (4) i = 1 에서 `heapify down`

- **노드(인덱스 1)**의 값 = `60`
- 왼쪽 자식(인덱스 2) = `80`, 오른쪽 자식(인덱스 3) = `70`
- 더 큰 자식 = `80` (인덱스 2)
- `60 < 80` → 교환!

```
교환 후:
인덱스:    1   2   3   4   5   6   7   8
값:      [80, 60, 70, 40, 20, 30, 50, 10]
               ↑        ↑
           (1)번   (2)번 교환
```

트리:

```
                (80)
               /    \
            (60)     (70)
            /   \    /  \
         (40)  (20)(30) (50)
         /
       (10)
```

- 이제 인덱스 1에 `80`, 인덱스 2에 `60`
- 새롭게 내려간 인덱스 2(값=60)는 왼쪽 자식(인덱스 4=40), 오른쪽 자식(인덱스 5=20)보다 크므로 (60 ≥ 40, 60 ≥ 20) 더 이상 교환 없음 → 종료

---

### 3) 최종 결과: 완성된 최대 힙

최종적으로 배열 상태는:

```
인덱스:    1   2   3   4   5   6   7   8
값:      [80, 60, 70, 40, 20, 30, 50, 10]
```

이를 **트리로 시각화**하면:

```
                 (80)  <-- 루트
               /      \
            (60)      (70)
            /   \     /  \
         (40)  (20) (30) (50)
         /
       (10)
```

- **힙 성질(부모 ≥ 자식)** 검사:
    - 80 ≥ (60, 70)
    - 60 ≥ (40, 20), 70 ≥ (30, 50)
    - 40 ≥ (10)
- **완전 이진 트리** 형태 (인덱스 1 ~ 8 빈틈 없이 채움).

결과적으로, 주어진 배열 `60, 20, 70, 10, 80, 30, 50, 40`을 **Bottom-Up** 방식으로 `build heap` 한 뒤,  
**최대 힙**을 완성한 모습이 위와 같습니다.

---

##### 정리

1. **초기 배열**을 **완전 이진 트리 형태**로 일단 배치한다. (인덱스 1부터 순서대로)
2. **`i = ⌊N/2⌋`부터 1까지** 차례대로 내려가며, 각 노드에 대해 “더 큰 자식”과 교환하는 방식으로 `heapify down`을 수행한다.
3. 모든 노드가 자식보다 크거나 같은 상태(최대 힙 성립)로 만든다.

이 과정을 통해, `O(N)` 시간 안에 **초기 힙(최대 힙)**을 빠르게 구축할 수 있습니다.

> 힙이 준비되면, 이후에 삽입/삭제가 일어날 때마다 개별적으로 `heapify up/down` 과정을 통해 힙 속성을 유지합니다.

이상으로 `60, 20, 70, 10, 80, 30, 50, 40` 예시를 통한 **초기 힙 빌드(Build Heap)** 과정을 마쳤습니다.


---

## 7. 자바에서 우선순위 큐를 어떻게 쓸까?

**Q7.** _"자바 기준 코딩 테스트할 때, 우선순위 큐는 어떻게 코드로 구현하나요?"_

**A7.**
- 자바에는 이미 `PriorityQueue<E>` 클래스가 제공됩니다.
- 내부적으로 **최소 힙(min heap)** 형태를 사용하고 있기 때문에, 기본적으로 **가장 작은 값**이 먼저 나온다는 점에 주의하세요.

### 예시 코드

```java
import java.util.PriorityQueue;

public class PriorityQueueExample {
    public static void main(String[] args) {
        // 우선순위 큐(기본: 최소 힙)
        PriorityQueue<Integer> pq = new PriorityQueue<>();

        // 삽입
        pq.offer(3);
        pq.offer(1);
        pq.offer(5);
        pq.offer(2);

        // 출력 확인
        System.out.println("우선순위 큐의 원소들: " + pq); 
        // 예: [1, 2, 5, 3] (내부 구조를 직접 보장하지는 않지만, 최소 힙 기반)

        // 가장 작은 값 꺼내기
        System.out.println("가장 작은 값: " + pq.peek()); // 1
        System.out.println("가장 작은 값 꺼내기: " + pq.poll()); // 1 반환 후 제거
        System.out.println("가장 작은 값 꺼내기: " + pq.poll()); // 이제 2
    }
}
```

- **만약 최대 힙**으로 쓰고 싶다면?
    - **Comparator**(정렬 기준)를 재정의하거나, **음수 값을 삽입**하는 트릭을 쓰는 방법 등 여러 가지가 있습니다.
    - 간단하게 최대 힙을 만들려면 `PriorityQueue<Integer> maxPQ = new PriorityQueue<>(Collections.reverseOrder());` 처럼 선언할 수 있어요.

---

## 8. 구현을 직접 해봐야 이해가 잘 될 것 같은데, 간단한 힙을 만들어볼 수 있나요?

**Q8.** _"직접 힙 자료구조를 만들어보고 싶어요! 예시 코드를 간단히 보여주실 수 있을까요?"_

**A8.**  
아래는 **최소 힙(min heap)**을 예시로 한 간단한 구현입니다. (코딩 테스트 수준)

```java
import java.util.ArrayList;
import java.util.List;

public class MinHeap {
    private List<Integer> heap;

    public MinHeap() {
        heap = new ArrayList<>();
        heap.add(0); // 인덱스 1부터 사용하기 위해 더미 노드
    }

    public void insert(int val) {
        // 1. 가장 뒤에 삽입
        heap.add(val);
        int idx = heap.size() - 1;

        // 2. 부모와 비교하여 올라가기
        while (idx > 1 && heap.get(idx) < heap.get(idx / 2)) {
            swap(idx, idx / 2);
            idx /= 2;
        }
    }

    public int pop() {
        if (heap.size() <= 1) {
            return -1; // 예외처리
        }

        // 1. 루트 값을 반환하고, 마지막 노드를 루트로
        int top = heap.get(1);
        heap.set(1, heap.get(heap.size() - 1));
        heap.remove(heap.size() - 1);

        // 2. 아래로 내려가며 정렬
        int idx = 1;
        while (true) {
            int left = idx * 2;
            int right = idx * 2 + 1;
            int smallest = idx;

            if (left < heap.size() && heap.get(smallest) > heap.get(left)) {
                smallest = left;
            }
            if (right < heap.size() && heap.get(smallest) > heap.get(right)) {
                smallest = right;
            }
            if (smallest == idx) break;

            swap(idx, smallest);
            idx = smallest;
        }

        return top;
    }

    private void swap(int i, int j) {
        int temp = heap.get(i);
        heap.set(i, heap.get(j));
        heap.set(j, temp);
    }

    public int peek() {
        if (heap.size() <= 1) {
            return -1; 
        }
        return heap.get(1);
    }

    public static void main(String[] args) {
        MinHeap mh = new MinHeap();
        mh.insert(5);
        mh.insert(2);
        mh.insert(8);
        mh.insert(1);

        System.out.println(mh.peek()); // 1
        System.out.println(mh.pop());  // 1
        System.out.println(mh.pop());  // 2
        System.out.println(mh.pop());  // 5
        System.out.println(mh.pop());  // 8
    }
}
```

- **핵심 로직**
    - `insert()` 시에는 **위로 올라가며(Heapify Up)** 부모 노드와 교환.
    - `pop()` 시에는 **아래로 내려가며(Heapify Down)** 자식 노드 중 더 작은 쪽과 교환.

---

## 9. 정리

**Q9.** _"결국 우선순위 큐와 힙을 한 문장으로 요약한다면요?"_

**A9.**
- **우선순위 큐**는 "가장 우선순위가 높은(또는 낮은) 요소를 효율적으로 꺼내기 위한 추상 자료구조"
- **힙(Heap)**은 "완전 이진 트리 형태로 부모-자식 간 대소관계를 유지하며, 우선순위 큐 기능을 효율적으로 구현하는 자료구조"

쉽게 말해서,
- **우선순위 큐**는 '효율적 꺼내기'라는 **문제**를 해결하기 위한 **목적/인터페이스**
- **힙**은 그 **문제 해결**을 위한 **대표적인 도구**

---

## 10. 마무리

- **핵심 포인트**
    1. 우선순위 큐(추상)와 힙(구현)을 구분하기.
    2. 힙은 **완전 이진 트리** + **힙 불변식**(부모-자식 간 대소관계)으로 구성.
    3. 삽입/삭제 시 **위로 올라가기** / **아래로 내려가기** 로 O(log n) 시간 복잡도 달성.
    4. 자바에서는 `PriorityQueue` 클래스를 기본 제공(기본적으로 최소 힙).

- 더 깊게 파고들면, **피보나치 힙**, **이진 힙**, **이진검색트리 기반 우선순위 큐**, **Binomial Heap** 등 다양한 자료구조가 있지만, 코딩 테스트에서는 **`PriorityQueue` + 기본 힙 구조**만 잘 이해하면 충분합니다.
