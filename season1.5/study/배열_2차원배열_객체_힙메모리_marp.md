

---
marp: true
paginate: true
theme: default
_class: lead
backgroundColor: #ffffff


---

<!-- 슬라이드 0 -->
# Java 배열, 2차원 배열, 객체, 힙 메모리
**정리 및 시각 자료**  

<br/>

- **배열**(Array) → **2차원 배열**(2D Array) → **객체**(Object)로 확장되는 개념  
- **힙 메모리**(Heap Memory)에서의 배열·객체 저장 구조  
- 주요 특징과 **가비지 컬렉션**(GC)

<footer>By. Your Name</footer>

---

<!-- 슬라이드 1: 소개 -->
## 0. 이 문서에 대해서

- **배열**과 **2차원 배열**, 그리고 자바의 **객체**와 **힙 메모리** 개념 이해를 목표
- **코딩 테스트**나 **실무**에서 유용하게 활용할 수 있는 지식
- **시각 자료**와 코드 예시를 곁들여 단계별로 확장 과정을 살펴봄

---

<!-- 슬라이드 2: 배열 1 -->
## 1. 배열(Array)

### 1.1 배열의 개념
- **정의**: 같은 타입 데이터를 인덱스로 관리하는 **연속적 구조**(자바에서 연속은 논리적으로 이해)
- **특징**  
  1. 고정 크기: 생성 시 크기 확정, 이후 변경 불가  
  2. 인덱스를 통한 접근: 임의 접근(랜덤 액세스)이 가능  
  3. 배열도 객체: 자바에서 배열은 `Object`를 상속받는 하나의 객체

---

<!-- 슬라이드 3: 배열 2 (메모리 구조) -->
### 1.2 배열의 메모리 구조
- **힙 메모리에 생성**  
  - `new`로 생성된 인스턴스(배열 포함)는 힙에 저장
- **참조 변수는 스택에**  
  - 예) `int[] arr`: 스택에 참조(주소)만 저장, 실제 데이터는 힙에 존재

```java
int[] arr = new int[5]; 
arr[0] = 10;
```

---

<!-- 슬라이드 4: 배열 3 (시각적 예시) -->
#### 1.2.1 시각적 예시 (1차원 배열)

```
┌─────────┐
│  Stack  │
├─────────┤
│ arr ────────────────┐   (arr 변수는 스택에 있음)
└─────────┘           │
                      ↓ (힙 영역에 있는 배열 객체의 주소)
                ┌──────────────────┐
                │  arr 객체(힙)    │
                ├──────────────────┤
                │  [0]: 10         │
                │  [1]: 0          │
                │  [2]: 0          │
                │  [3]: 0          │
                │  [4]: 0          │
                └──────────────────┘
```

---

<!-- 슬라이드 5: 2차원 배열 1 -->
## 2. 2차원 배열(2D Array)

### 2.1 개념
- **정의**: “배열의 배열” 형태, `타입[][]`로 선언
- **특징**
    1. **가변 길이 가능**: 행마다 길이가 달라질 수 있음
    2. 실제로는 1차원 배열들의 배열

```java
int[][] matrix = new int[3][4];
matrix[0][0] = 1;
matrix[1][2] = 2;
```

---

<!-- 슬라이드 6: 2차원 배열 2 (메모리 구조) -->
### 2.2 메모리 구조

- `matrix`(스택): “행 배열” 객체의 주소
- “행 배열” 객체(힙): 길이 3의 배열 (각 요소가 `int[4]` 배열을 가리킴)
- 각 행(`matrix[0]`, `matrix[1]`, `matrix[2]`)도 힙에 별도로 할당된 `int[4]`

#### 2.2.1 시각적 예시

```
┌─────────┐
│  Stack  │
├─────────┤
│ matrix ────────────┐      (matrix 변수는 스택에 존재)
└─────────┘          │
                     ↓ (행 배열의 주소)
                ┌──────────────────┐
                │  matrix(힙)      │  <-- 행 배열 객체
                ├──────────────────┤
                │  [0] ────────────┐-->  ┌───────────────────┐
                │  [1] ────────────┼--->  │   matrix[1](힙)   │
                │  [2] ────────────┘-->  └───────────────────┘
                └──────────────────┘
```

---

<!-- 슬라이드 7: 객체 1 -->
## 3. 객체(Object)

### 3.1 자바 객체의 개념
- **정의**: 클래스(또는 인터페이스)로부터 생성된 **인스턴스**
- **배열 또한 객체**
    - 모든 배열(`int[]`, `String[]`)은 `Object`를 상속받음
    - `instanceof` 연산자로도 확인 가능

```java
class MyClass {
    int value;
}

MyClass obj = new MyClass();
obj.value = 100;
```

---

<!-- 슬라이드 8: 객체 2 (힙 메모리) -->
### 3.2 객체의 메모리 구조
1. **힙 메모리에 할당**
    - `new` 키워드로 생성된 객체, 힙 영역 저장
2. **참조(주소)로 접근**
    - 스택 혹은 다른 객체의 필드에 **참조**를 저장
    - 해당 참조로 힙 영역의 실제 데이터 접근

---

<!-- 슬라이드 9: 힙 메모리와 GC -->
## 4. 힙 메모리 & 자동 메모리 관리

- **힙 메모리(Heap)**: `new`로 생성된 인스턴스가 동적 할당되는 영역
- **가비지 컬렉션(GC)**: 더 이상 참조되지 않는 객체(도달 불가능 객체)를 자동 회수

#### 4.2 주의사항
1. **메모리 누수(Memory Leak)** 방지
    - 의도치 않게 계속 참조 중이면 GC로 회수 불가
2. **OutOfMemoryError**
    - 힙 공간 부족 시 발생
3. **객체 생성 비용**
    - 과도한 객체 생성/파괴는 잦은 GC 유발로 성능 저하

---

<!-- 슬라이드 10: 배열 → 객체 확장 -->
## 5. 배열 → 2차원 배열 → 객체, 개념 확장 흐름

1. **배열(1D) 기초**
    - 동일 타입 연속 데이터, 인덱스로 관리
2. **2차원 배열**
    - 실질적으로 1차원 배열들의 배열
    - 행-열 구조로 복잡 데이터 관리
3. **객체**
    - 데이터(필드)와 동작(메서드)의 추상화
    - 배열도 결국 객체 → 동적 할당, GC 대상

---

<!-- 슬라이드 11: 요약 -->
## 6. 전체 요약 및 주목할 점

1. **데이터 저장 관점**
    - 1D 배열: 동일 타입 빠른 접근
    - 2D 배열: 행과 열 구조로 관리
    - 객체: 복합 데이터 + 행위(메서드) 묶음
2. **메모리 관점**
    - 모든 배열·객체는 **힙**에, 스택엔 참조만
    - 2차원 배열은 행 배열 + 열 배열 구조
3. **참조(주소) 개념**
    - 여러 참조가 한 객체를 가리킬 수 있음
    - 참조가 없으면 GC로 회수
4. **성능 최적화**
    - 캐시 미스, 빈번한 GC 유발에 주의
    - 큰 배열/객체 재사용 고려

---

<!-- 슬라이드 12: 결론 -->
## 결론
- **배열**: 동일 타입 데이터의 효율적 관리
- **2차원 배열**: “배열의 배열”로 구조 확장
- **객체**: 데이터+행위를 포괄하는 상위 추상화
- 모두 힙에 생성, 스택에서 참조 관리
- 참조(주소) 개념과 GC 동작 이해가 필수

<br/>

**감사합니다!**

---

